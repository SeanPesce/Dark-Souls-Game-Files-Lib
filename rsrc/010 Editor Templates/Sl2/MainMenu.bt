//-----------------------------------------------------------
//--- 010 Editor v5.0 Binary Template
//
// File: Sl2/Sl2
// Author: Sean Pesce
// Revision: 0.5
// Purpose: Reading saved character data for the main menu
//          in Dark Souls: Prepare to Die Edition (PC)
//-----------------------------------------------------------
#ifndef _SL2_MAIN_MENU_BT
    #define _SL2_MAIN_MENU_BT

#include "Bnd4.bt"
#include "Character.bt"
#include "../Enum/Character.bt"

#define _DS1_SAVE_VERSION_NUM 19

typedef struct {
    local ubyte del_char = 0;
    if(GetBackColor() != cNone){
        del_char = 1;
    }
    SetBackColor(cNone);
    uint unknown_stat[6];
    if(del_char != 1){
        SetBackColor( cDkYellow );
        SetForeColor( cWhite );
    } else {
        SetBackColor(cSilver);
    }
    Color hair_color;
    Color eye_color;
    SetForeColor( cNone );
    if(del_char != 1){
        SetBackColor( cLtYellow );
    }
    ubyte face_geo_data[50];
    ubyte skin_tone;
    ubyte face_tex_data[49];
    SetBackColor( cNone );
    ubyte unknown_byte[60];
    
    if(del_char != 1){
        SetBackColor( cLtRed );
    } else {
        SetBackColor(cSilver);
    }
    
    enum ItemWeapon L_hand_primary <comment="Weapon ID">;
    enum ItemWeapon R_hand_primary <comment="Weapon ID">;
    enum ItemWeapon L_hand_secondary <comment="Weapon ID">;
    enum ItemWeapon R_hand_secondary <comment="Weapon ID">;
    enum ItemWeapon L_arrows <comment="Weapon ID">;
    enum ItemWeapon L_bolts <comment="Weapon ID">;
    enum ItemWeapon R_arrows <comment="Weapon ID">;
    enum ItemWeapon R_bolts <comment="Weapon ID">;
    enum ItemArmor head <comment="Armor ID">;
    enum ItemArmor torso <comment="Armor ID">;
    enum ItemArmor hands <comment="Armor ID">;
    enum ItemArmor legs <comment="Armor ID">;
    enum HairStyle hairstyle <comment="Armor ID">;
    enum ItemRing L_ring <comment="Accessory ID">;
    enum ItemRing R_ring <comment="Accessory ID">;
    enum UsableItem belt[5] <comment="Item ID">; // First item is left-most belt item
    SetBackColor( cNone );
    uint unknown_data[2];
} CharPreview;


typedef struct {
    wchar_t name[14] <bgcolor=cLtPurple>;
    uint unknown_stat[2];
    uint level <bgcolor=cSilver>;
    uint playtime <read=GetTimeStampNoMs, bgcolor=cSilver, comment="Time in seconds; overflows at 999:59:59 (3599999)">;
    uint earned_souls <bgcolor=cSilver>;
    ushort unknown_stat3[2];
    enum Location location  <bgcolor=cSilver, comment="Game world location string ID from 地名.fmg (Must be unpacked from msg/<LANGUAGE>/item.msgbnd.dcx)">;
    SetBackColor( cNone );
    CharPreview character_preview;
    ushort unknown_data[4];
} MainMenuCharPreview;


typedef struct {
    wchar_t name[14] <bgcolor=cSilver>;
    uint unknown_stat[2];
    uint level <bgcolor=cSilver>;
    uint playtime <read=GetTimeStampNoMs, bgcolor=cSilver>;
    uint earned_souls <bgcolor=cSilver>;
    ushort unknown_stat3[2];
    enum Location location  <bgcolor=cSilver>;
    SetBackColor( cSilver );
    CharPreview character_preview;
    SetBackColor( cNone );
    ushort unknown_data[4];
} DeletedCharPreview;


typedef struct {
    ubyte unused_bytes[(14*2)+(4*30)+162];
} EmptyCharPreview;


// Contains data for character previews on the main menu
typedef struct {
    local uint secondary_hash_calc_start = ((FTell() + 20) + (uint64)ReadUInt(FTell() + 16) - 16);
    local string header_hash_start = "";
    local string footer_hash_start = "";
    local string header_hash_calculated = "";
    local string footer_hash_calculated = "";
    local string header_hash_recalculated = ""; // Only used if existing footer hash was invalid
    local ubyte hash_verified[2] = GetChecksumStrings(FTell() + 20, (uint64)ReadUInt(FTell() + 16),
                                    secondary_hash_calc_start,
                                    header_hash_start, footer_hash_start, header_hash_calculated,
                                    footer_hash_calculated, header_hash_recalculated);
    if (hash_verified[0] == 0) {
        SetForeColor(cRed);
    }
    Checksum header(16);
    SetForeColor(cNone);
    uint length;
    uint version <bgcolor=cDkGray, fgcolor=cWhite, read=CheckMenuVersion, comment="If this value is changed, game will often display \"Wrong version\" error (Message ID = 45001). Some non-default values do work though.">;
    ushort unknown1[3];
    ubyte total_slots_maybe;
    ubyte unknown_flags[8];
    ubyte unknown_byte;
    ubyte slot_occupied[10] <bgcolor=cLtAqua, comment="1 or 0">;
    ubyte unknown_flags2[6];
    
    local uint char_index = 0;
    local ubyte char_check = 0;
    local ushort name_check = 0;
    for(char_index = 0; char_index < (meta.ContainerCount - 1); char_index++){
        char_check = ReadUByte(meta.chunks[meta.ContainerCount - 1].start + 40 + char_index);
        if(char_check != 0){
            MainMenuCharPreview preview_char;
        }else{
            name_check = ReadUShort( FTell() );
            if(name_check != 0){
                // Found leftover data from a deleted character
                DeletedCharPreview deleted_char;
            }else{
                EmptyCharPreview empty;
            }
            name_check = 0;
        }
    }
    
    local uint menu_data_start = meta.chunks[meta.ContainerCount - 1].start;
    local uint menu_data_size = meta.chunks[meta.ContainerCount - 1].block_size;
    ubyte unknown_sections[(menu_data_size - 16) - (FTell() - menu_data_start)];
    
    if (hash_verified[1] == 0) {
        SetForeColor(cRed);
    }
    Checksum footer(16);
    SetForeColor(cNone);
    ubyte padding[meta.chunks[meta.ContainerCount - 1].space_size];
} MainMenu <read=GetMenuSlotChecksumStatus, comment=GetMenuSlotChecksumCorrection>;


string CheckMenuVersion(uint &ver) {
    string version_check_string = "";
    if(ver == _DS1_SAVE_VERSION_NUM) {
        SPrintf(version_check_string, "%d", ver);
    } else {
        SPrintf(version_check_string, "%d    (WARNING: Version number should be %d)", ver, _DS1_SAVE_VERSION_NUM);
    }
    return version_check_string;
}


#endif // _SL2_MAIN_MENU_BT
