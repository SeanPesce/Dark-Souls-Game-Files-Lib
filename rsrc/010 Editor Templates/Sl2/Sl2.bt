//----------------------------------------------------------------------------
//--- 010 Editor v5.0 Binary Template
//
// File: Sl2/Sl2.bt
// Author: Tarvitz & Sean Pesce
// Revision: 0.0.1
// Purpose: Parsing Dark Souls: Prepare to Die Edition save files (*.sl2)
//----------------------------------------------------------------------------
#ifndef _DS1_SL2_BT
    #define _DS1_SL2_BT

#include "Bnd4.bt";
#include "Character.bt";
#include "Backpack.bt"
#include "Unknown.bt";
#include "../Online.bt";
#include "MainMenu.bt";
#include "../Enum/Location.bt";
#include "../Enum/Character.bt"


local string checksum_verification_messages = "\n";

typedef struct{
    ubyte flag1 : 1 ;
    ubyte flag2 : 1 ;
    ubyte flag3 : 1 ;
    ubyte flag4 : 1 ;
    ubyte flag5 : 1 ;
    ubyte flag6 : 1 ;
    ubyte flag7 : 1 ;
    ubyte flag8 : 1 ;
} BitFlags;

typedef struct{
    ubyte face_geo_data[50] <bgcolor=cLtYellow>;
    // I suspect the character creation options can be found around here
    ubyte skin_tone <bgcolor=cLtYellow, fgcolor=cBlue>;
    ubyte face_tex_data[49] <bgcolor=cLtYellow>;
    byte UnknownData4[8];
} CharacterParams;

typedef struct{
    Item magic;
    uint count;
} Attuned;

// I'm not sure exactly how these map, if they are just shorts or UnknownTuple
typedef struct{
    UnknownTuple unknown1 <bgcolor=cLtYellow>;
    UnknownTuple petrus <comment="Shrug = 21, Look Skyward = 23, Unlearned = 20">;
    UnknownTuple unknown3 <bgcolor=cLtYellow>;
    UnknownTuple unknown4 <bgcolor=cLtYellow>;
} LearnedGestures;

typedef struct{
    UnknownTuple UnknownData5a[10] <bgcolor=cLtYellow>;
    // Equipped gestures are stored somewhere else, this is specifically if they are available or not
    // Enabling this won't remove the dialog option and vice verse
    LearnedGestures gestures;
    //maybe more gestures?
    UnknownTuple UnknownData5b[4] <bgcolor=cLtYellow>;
    uint ZeroPad[16] <bgcolor=cWhite>;
} Gestures;

// This is specifically bonfires RESTED AT, not lit. (i.e. relevant to which bonfires player can warp to. Only warpable bonfires in this struct??)
typedef struct{

    // I noticed that if you do not light any bonfires in the Undead Asylum, and then you die after running past the second bonfire, your spawn point is still set there.
    // Most likely the game state moves your spawn point automatically during the tutorial so you don't get trapped behind the locked gate.

    // 2,8,13,14,28,29,30
    // Must be from {depths, fairlady, anorlondo1, anorlondotomb, paintedworld, tombgiants1}?
    // Undead Burg first bonfire not here
    uint bonfireenabled1 : 1 <comment="Undead Parish"> ;
    uint bonfireenabled2 : 1 ;
    uint bonfireenabled3 : 1 ;
    uint bonfireenabled4 : 1 ;
    uint bonfireenabled5 : 1 ;
    uint bonfireenabled6 : 1 ;
    uint bonfireenabled7 : 1 ;
    uint bonfireenabled8 : 1 ;
    uint bonfireenabled9 : 1 <comment="Chamber of the Princess">;
    uint bonfireenabled10 : 1 ;
    uint bonfireenabled11 : 1 <comment="Altar of Sunlight">;
    uint bonfireenabled12 : 1 ;
    uint bonfireenabled13 : 1 ;
    uint bonfireenabled14 : 1 ;
    uint bonfireenabled15 : 1 ;
    uint bonfireenabled16 : 1 <comment="Firelink Shrine">; // Enabled when arriving at Firelink first time
    uint bonfireenabled17 : 1 ;
    uint bonfireenabled18 : 1 ;
    uint bonfireenabled19 : 1 ;
    uint bonfireenabled20 : 1 ;
    uint bonfireenabled21 : 1 ;
    uint bonfireenabled22 : 1 ;
    uint bonfireenabled23 : 1 ;
    uint bonfireenabled24 : 1 ;
    uint bonfireenabled25 : 1 ;
    uint bonfireenabled26 : 1 ;
    uint bonfireenabled27 : 1 ;
    uint bonfireenabled28 : 1 ;
    uint bonfireenabled29 : 1 ;
    uint bonfireenabled30 : 1 ;
    uint bonfireenabled31 : 1 ;
    uint bonfireenabled32 : 1 ;
} Bonfires;

typedef struct{
    uint unknown[4]; // I think here is where we can find bonfire 'lit' info
    byte UnknownData8b[38-20] <bgcolor=cLtYellow>;
    Bonfires bonfiresRestedAt<bgcolor=cLtGreen>;
    byte unknown2[214] <bgcolor=cLtYellow>;
    byte filler[788] <bgcolor=cWhite>;
    byte unknown3[224] <bgcolor=cLtYellow>;
    byte filler2[16] <bgcolor=cWhite>;
} BonfireSection;




typedef struct {
    local int unknown_size_1 = sizeof(StatsUnknown1);
    local int stats_size = sizeof(Stats);
    local int pack_size = sizeof(Pack);
    local int backpack_amount = 2048; // Is this a hard-coded constant? // I don't know, we could try filling the backpack 
    //                                   with 2047 items and see what happens when we try to pick up another. If it refuses
    //                                   it's constant, if it dynamically resizes the pack then we know

    local string header_hash_start = "";
    local string footer_hash_start = "";
    local string header_hash_calculated = "";
    local string footer_hash_calculated = "";
    local string header_hash_recalculated = ""; // Only used if existing footer hash was invalid (header hash is calculated using footer hash)
    local ubyte hash_verified[2] = GetChecksumStrings(FTell() + 20, (uint64)ReadUInt(FTell() + 16),
                                    meta.chunks[slots+1].start - (16 + meta.chunks[slots].space_size),
                                    header_hash_start, footer_hash_start, header_hash_calculated,
                                    footer_hash_calculated, header_hash_recalculated);

    if (hash_verified[0] == 0) {
        SetForeColor(cRed);
    }
    Checksum header; // This is written after the MD5 in the footer of the save slot is written, it includes all parts of the save slot except for the ChecksumHeader
    SetForeColor(cNone);
    
    uint length <read=GetDecAndHexValuesUInt, fgcolor=cWhite, bgcolor=cLtBlue>; // Number of bytes that should be included in the checksum, 393216 ( Entire slot is 393248 )
    uint unknown_a[2];
    uint playtime <read=GetTimeStamp, comment="Time in milliseconds; maxes out at 999:59:59:000 (3599999000)">; // Milliseconds since game start (verified); maxes out at 3599999000 (999:59:59)
    StatsUnknown1 unknown <comment="Unknown data">;

    Stats stats;
    Pack pack;

    uint backpack_items_amount;
    uint backpack_keys_amount;
    uint backpack_size;
    // 0-63 indexes for utils box
    local uint utilbox_size = 64;
    local uint itembox_size = 0;
    if(backpack_size > 0 && backpack_size >= utilbox_size) {
        itembox_size = backpack_size - utilbox_size;
    }

    // Warning: If you've dropped an item, there may be blank items interleaved among the existing
    // items and some items will be pushed into the empty part of the box display
    PartiallyUsedBox util_box(utilbox_size,backpack_keys_amount);
    PartiallyUsedBox item_box(itembox_size,backpack_items_amount);

    uint lastindex; // Item with the highest index // Whatever that means? Not tested
    Attuned attunementslots[12];
    uint UnknownData1; // Going from hydra, to beating Ornstein & Smough, this changed from 1 to 0

    uint equippedItems[5]; // Could these also be the index-remember-previous-selection feature?

    UnknownTuple UnknownData2[10]<bgcolor=cLtYellow>;

    Color hair; // @ address: 0xE644
    Color eye; 
    CharacterParams creationdata;

    BottomlessBox box[backpack_amount];

    Gestures gestures;

    // End part of the play-through (NG+) counter looks like it's almost in a box struct?
    UnknownBlob1 playthrough_counter;
    UnknownBox unknown_box[64];
    UnknownStruct unknown_box_2[120];

    UnknownBlob2 counters;


    // Section length = 0x500
    BonfireSection firstsection;
    UnknownBulkSection unknownSections[72];
    //unknownSection[2].marker[8] Includes the bit that unlocks the Undead Burg ladder shortcut. Bit 0x08 if my calculations are correct
    //unknownSection[2].marker[91] 0A-08 indicates whether Sunlight Altar bonfire has been lit?

    byte zerofill[10] <bgcolor=cWhite,fgcolor=cGreen>;

    local uint mark = FTell();

    OnlineData online;

    // Dynamic length zero pad; skip to next part with numbers
    FSeek(mark + 131242);

    //0x56280 Undead Burg bonfire?
    UnknownArea areadata[2578] <fgcolor=cGray, bgcolor=cWhite>;  // I'm getting indications that this is just garbage data?
    if (hash_verified[1] == 0) {
        SetForeColor(cRed);
    }
    Checksum footer; // MD5 checksum of all bytes in this save slot (excluding header and length fields)
    SetForeColor(cNone);
    // Secondary checksum isn't actually required to be correct to form a valid save file; save file loads despite it being edited.

    ubyte offset[meta.chunks[slots].space_size] <bgcolor=cWhite>;
} SaveSlot <read=GetChecksumStatus, name=GetSlotCharName, comment=GetChecksumCorrection>;


string GetSlotCharName(SaveSlot &s) {
    return "SaveSlot (" + WStringToString(s.stats.name) + ")";
}


string GetDecAndHexValuesUInt(uint val) {
    local string ret_str = "";
    SPrintf(ret_str, "%d (0x%x)", val, val);
    return ret_str;
}

string GetTimeStamp(uint val) {
    local ubyte hours = val / 3600000;
    local ubyte mins = (val - (hours * 3600000)) / 60000;
    local ubyte secs = ((val - (hours * 3600000)) - (mins * 60000)) / 1000;
    local ushort ms = ((val - (hours * 3600000)) - (mins * 60000)) - (secs * 1000);
    local string time_str = "";
    local string hours_pad = "";
    local string mins_pad = "";
    local string secs_pad = "";
    local string ms_pad = "";
    if(hours < 10)
        hours_pad = "0";
    if(mins < 10)
        mins_pad = "0";
    if(secs < 10)
        secs_pad = "0";
    if(ms < 100)
        ms_pad = "0";
    if(ms < 10)
        ms_pad += "0";
    SPrintf(time_str, "%s%d:%s%d:%s%d:%s%d", hours_pad, hours, mins_pad, mins, secs_pad, secs, ms_pad, ms);
    return time_str;
}

string GetTimeStampNoMs(uint val) {
    local ubyte hours = val / 3600;
    local ubyte mins = (val - (hours * 3600)) / 60;
    local ubyte secs = (val - (hours * 3600)) - (mins * 60);
    local string time_str = "";
    local string hours_pad = "";
    local string mins_pad = "";
    local string secs_pad = "";
    if(hours < 10)
        hours_pad = "0";
    if(mins < 10)
        mins_pad = "0";
    if(secs < 10)
        secs_pad = "0";
    SPrintf(time_str, "%s%d:%s%d:%s%d", hours_pad, hours, mins_pad, mins, secs_pad, secs);
    return time_str;
}

string ChecksumToString(Checksum &cs) {
    local string hash_str = "";
    local ubyte current_b = 0;
    hash_str = "";
    for (current_b = 0; current_b < 16; current_b++) {
        if(current_b > 0 && cs.md5[current_b] < 16) {
            SPrintf(hash_str, "%s0", hash_str);
        }
        SPrintf(hash_str, "%s%x", hash_str, (ubyte)cs.md5[current_b]);
    }
    return hash_str;
}


typedef struct {
    local string header_hash_start = "";
    local string footer_hash_start = "";
    local string header_hash_calculated = "";
    local string footer_hash_calculated = "";
    local string header_hash_recalculated = "";
    local ubyte hash_verified[2] = GetChecksumStrings(FTell() + 20, (uint64)ReadUInt(FTell() + 16),
                                    meta.chunks[slots+1].start - (16 + meta.chunks[slots].space_size),
                                    header_hash_start, footer_hash_start, header_hash_calculated,
                                    footer_hash_calculated, header_hash_recalculated);

    if (hash_verified[0] == 0) {
        SetForeColor(cRed);
    }
    Checksum header;
    SetForeColor(cNone);
    uint length <fgcolor=cWhite, bgcolor=cLtBlue>;
    ubyte data[8+4+0x4C];
    Stats stats;
    Pack pack;
    uint data2[3];
    byte utilbox[0x1c*64];
    byte itembox[0x1c*(2048-64)];
    byte data3[0x6c+0x10+0x10+0x28+0x14+4+0x64];
    byte bottomlessbox[0x20*2048];
    Gestures gestures;
    UnknownBlob1 playthrough_counter;
    UnknownBox unknown_box[64];
    UnknownStruct unknown_box_2[120];
    UnknownBlob2 counters;
    BonfireSection firstsection;
    byte unknownSections[72*0x500];
    byte zerofill[10] <bgcolor=cWhite,fgcolor=cGreen>;
    ubyte onlinedata[131242]<bgcolor=cLtPurple>;
    UnknownArea areadata[2578] <fgcolor=cGray, bgcolor=cWhite>;
    if (hash_verified[1] == 0) {
        SetForeColor(cRed);
    }
    Checksum footer;
    SetForeColor(cNone);
    ubyte offset[12] <bgcolor=cWhite>;
} EmptySlot <read=GetEmptySlotChecksumStatus, comment=GetEmptySlotChecksumCorrection>;


string GetChecksumStatus(SaveSlot &last_slot) {
    local string return_string = "";
    if (last_slot.hash_verified[0] == 1 && last_slot.hash_verified[1] == 1) {
        SPrintf(return_string, "Header: %s (Valid)", last_slot.header_hash_calculated);
    } else if (last_slot.hash_verified[1] != 1) {
        SPrintf(return_string, "Header: %s (INVALID: Footer checksum is incorrect)", last_slot.header_hash_start);
    } else {
        SPrintf(return_string, "Header: %s (INVALID: Header checksum is incorrect)", last_slot.header_hash_start);
    }
    return return_string;
}

string GetChecksumCorrection(SaveSlot &last_slot) {
    local string return_string = "";
    if (last_slot.hash_verified[0] == 1 && last_slot.hash_verified[1] == 1) {
        SPrintf(return_string, "Footer: %s (Valid)", last_slot.footer_hash_calculated);
    } else if (last_slot.hash_verified[1] != 1) {
        SPrintf(return_string, "Corrected footer: %s", last_slot.footer_hash_calculated);
    } else {
        SPrintf(return_string, "Corrected header: %s", last_slot.header_hash_calculated);
    }
    return return_string;
}

string GetEmptySlotChecksumStatus(EmptySlot &last_slot) {
    local string return_string = "";
    if (last_slot.hash_verified[0] == 1 && last_slot.hash_verified[1] == 1) {
        SPrintf(return_string, "Header: %s (Valid)", last_slot.header_hash_calculated);
    } else if (last_slot.hash_verified[1] != 1) {
        SPrintf(return_string, "Header: %s (INVALID: Footer checksum is incorrect)", last_slot.header_hash_start);
    } else {
        SPrintf(return_string, "Header: %s (INVALID: Header checksum is incorrect)", last_slot.header_hash_start);
    }
    return return_string;
}

string GetEmptySlotChecksumCorrection(EmptySlot &last_slot) {
    local string return_string = "";
    if (last_slot.hash_verified[0] == 1 && last_slot.hash_verified[1] == 1) {
        SPrintf(return_string, "Footer: %s (Valid)", last_slot.footer_hash_calculated);
    } else if (last_slot.hash_verified[1] != 1) {
        SPrintf(return_string, "Corrected footer: %s", last_slot.footer_hash_calculated);
    } else {
        SPrintf(return_string, "Corrected header: %s", last_slot.header_hash_calculated);
    }
    return return_string;
}

string GetMenuSlotChecksumStatus(MainMenu &mm) {
    local string return_string = "";
    if (mm.hash_verified[0] == 1 && mm.hash_verified[1] == 1) {
        SPrintf(return_string, "Header: %s (Valid)", mm.header_hash_calculated);
    } else if (mm.hash_verified[1] != 1) {
        SPrintf(return_string, "Header: %s (INVALID: Footer checksum is incorrect)", mm.header_hash_start);
    } else {
        SPrintf(return_string, "Header: %s (INVALID: Header checksum is incorrect)", mm.header_hash_start);
    }
    return return_string;
}

string GetMenuSlotChecksumCorrection(MainMenu &mm) {
    local string return_string = "";
    if (mm.hash_verified[0] == 1 && mm.hash_verified[1] == 1) {
        SPrintf(return_string, "Footer: %s (Valid)", mm.footer_hash_calculated);
    } else if (mm.hash_verified[1] != 1) {
        SPrintf(return_string, "Corrected footer: %s", mm.footer_hash_calculated);
    } else {
        SPrintf(return_string, "Corrected header: %s", mm.header_hash_calculated);
    }
    return return_string;
}

ubyte[2] GetChecksumStrings(uint start, uint64 size, uint secondary_start, string &current_primary, string &current_secondary,
                            string &calculated_primary, string &calculated_secondary, string &recalculated_primary) {
    local uchar md5_hash[33];
    local uint64 range_size = size;
    local uint ret_bytes = ChecksumAlgBytes(CHECKSUM_MD5, md5_hash, start, size - 16);
    local uint current_ret_b = 0;
    local ubyte valid[2];
    valid[0] = 1;
    valid[1] = 1;
    for (current_ret_b = 0; current_ret_b < ret_bytes; current_ret_b++) {
        if (md5_hash[current_ret_b] != ReadUByte(secondary_start + current_ret_b)) {
            valid[1] = 0;
        }
        if(ReadUByte(secondary_start + current_ret_b) < 16) {
            SPrintf(current_secondary, "%s0", current_secondary);
        }
        SPrintf(current_secondary, "%s%x", current_secondary, ReadUByte(secondary_start + current_ret_b));
        if(md5_hash[current_ret_b] < 16) {
            SPrintf(calculated_secondary, "%s0", calculated_secondary);
        }
        SPrintf(calculated_secondary, "%s%x", calculated_secondary, md5_hash[current_ret_b]);
    }
    SPrintf(calculated_secondary, "%s", calculated_secondary);
    
    if (valid[1] != 1) {
        SPrintf(checksum_verification_messages,
          "%s[WARNING] Invalid footer checksum for slot %d:\n          Current hash:     %s\n          Calculated hash:  %s\n",
          checksum_verification_messages, slots, current_secondary, calculated_secondary);
    }
    
    // @TODO: If some preprocessor macro is defined, use void OverwriteBytes( int64 start, int64 size, uchar value=0 ) to overwrite incorrect checksums (or make copy of file with fixed)
    
    ret_bytes = ChecksumAlgBytes(CHECKSUM_MD5, md5_hash, start-4, size + 4);
    
    for (current_ret_b = 0; current_ret_b < ret_bytes; current_ret_b++) {
        if (md5_hash[current_ret_b] != ReadUByte((start-20) + current_ret_b)) {
            valid[0] = 0;
        }
        if(ReadUByte((start-20) + current_ret_b) < 16) {
            SPrintf(current_primary, "%s0", current_primary);
        }
        SPrintf(current_primary, "%s%x", current_primary, ReadUByte((start-20) + current_ret_b));
        if(md5_hash[current_ret_b] < 16) {
            SPrintf(calculated_primary, "%s0", calculated_primary);
        }
        SPrintf(calculated_primary, "%s%x", calculated_primary, md5_hash[current_ret_b]);
    }
    
    if (valid[0] != 1) {
        SPrintf(checksum_verification_messages,
          "%s[WARNING] Invalid header checksum for slot %d:\n          Current hash:     %s\n          Calculated hash:  %s\n",
          checksum_verification_messages, slots, current_primary, calculated_primary);
    }
    
    if (valid[0] != 1 || valid[0] != 1) {
        SPrintf(checksum_verification_messages, "%s\n", checksum_verification_messages);
    }
    
    // @TODO: If footer hash is invalid, recalculate header using correct footer
    
    return valid;
}


LittleEndian(); 

local uint tag = ReadUInt( FTell() );

// IDENTIFY BND4 token
// This is 0x20434f43 for x360 saves ("COC "?)
// Another tag for x360 is at 0x360: 3a084d4e (Little Endian)
if( tag != 0x34444e42)
{
    Warning("Not a valid Dark Souls: Prepare to die Edition save file");
    return -1;
}

SetBackColor( cLtGray );
BND4 meta;

// Slots should be configured according to record's ContainerCount // Not really, what if you've deleted slot 1 but slot 2 exists?
if (meta.SlotMetaBlockSize != 0x20)
{
    Warning("Not a valid Dark Souls: prepare to Die Edition save file");
    return -1;
}

local uint slots = 0;
local ubyte test = 0;
local ubyte slot_filled[meta.ContainerCount - 1];
for( slots = 0; slots < meta.ContainerCount; slots++ )
{
    // If a main menu flag has value of 1, corresponding save slot is occupied
    
    if(slots != (meta.ContainerCount - 1))
    {
        test = ReadUByte(meta.chunks[meta.ContainerCount - 1].start + 40 + slots);
        if( test == 1 ) {
            slot_filled[slots] = 1;
            SaveSlot slot;
        } else {
            slot_filled[slots] = 0;
            EmptySlot empty;
        }
    } else {
        MainMenu menu_data;
    }
}

SetBackColor(cRed);
while(!FEof()) {
    ubyte eof_padding <comment="Unknown bytes; verify that this is a valid Dark Souls: PtDE save file and check that the template is working correctly.">;
}
SetBackColor(cLtGray);

Printf("%s", checksum_verification_messages);

#endif // _DS1_SL2_BT