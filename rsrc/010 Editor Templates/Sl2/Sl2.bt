//----------------------------------------------------------------------------
//--- 010 Editor v5.0 Binary Template
//
// File: Sl2/Sl2.bt
// Author: Tarvitz & Sean Pesce
// Revision: 0.0.1
// Purpose: Parsing Dark Souls: Prepare to Die Edition save files (*.sl2)
//----------------------------------------------------------------------------
#ifndef _DS1_SL2_BT
    #define _DS1_SL2_BT

#include "Bnd4.bt"
#include "Character.bt"
#include "Backpack.bt"
#include "../Online.bt"
#include "MainMenu.bt"
#include "../Enum/Location.bt"
#include "../Enum/Character.bt"


local string checksum_verification_messages = "\n";

typedef struct{
    ubyte flag1 : 1 ;
    ubyte flag2 : 1 ;
    ubyte flag3 : 1 ;
    ubyte flag4 : 1 ;
    ubyte flag5 : 1 ;
    ubyte flag6 : 1 ;
    ubyte flag7 : 1 ;
    ubyte flag8 : 1 ;
} BitFlags;


typedef struct {
    local int backpack_amount = 2048; // Is this a hard-coded constant? // I don't know, we could try filling the backpack 
    //                                   with 2047 items and see what happens when we try to pick up another. If it refuses
    //                                   it's constant, if it dynamically resizes the pack then we know

    local string header_hash_start = "";
    local string footer_hash_start = "";
    local string header_hash_calculated = "";
    local string footer_hash_calculated = "";
    local string header_hash_recalculated = ""; // Only used if existing footer hash was invalid (header hash is calculated using footer hash)
    local ubyte hash_verified[2] = GetChecksumStrings(FTell() + 20, (uint64)ReadUInt(FTell() + 16),
                                    meta.chunks[slots+1].start - (16 + meta.chunks[slots].space_size),
                                    header_hash_start, footer_hash_start, header_hash_calculated,
                                    footer_hash_calculated, header_hash_recalculated);

    if (ReadUInt(FTell()+16) != 0 && hash_verified[0] == 0) {
        SetForeColor(cRed);
    } else if (ReadUInt(FTell()+16) == 0) {
        SetForeColor(cGray);
    }
    Checksum header(16); // This is written after the MD5 in the footer of the save slot is written, it includes all parts of the save slot except for the ChecksumHeader
    SetForeColor(cNone);
    
    uint length <read=GetDecAndHexValuesUInt, fgcolor=cWhite, bgcolor=cLtBlue>; // Number of bytes that should be included in the checksum, 393216 ( Entire slot is 393248 )
    uint unknown_a[2];
    uint playtime <read=GetTimeStamp, comment="Time in milliseconds; maxes out at 999:59:59:000 (3599999000)">; // Milliseconds since game start (verified); maxes out at 3599999000 (999:59:59)
    StatsUnknown1 unknown(0) <comment="Unknown data">;

    Stats stats;
    Pack pack(0);

    uint backpack_items_amount;
    uint backpack_keys_amount;
    uint backpack_size;
    // 0-63 indexes for utils box
    local uint utilbox_size = 64;
    local uint itembox_size = 0;
    if(backpack_size > 0 && backpack_size >= utilbox_size) {
        itembox_size = backpack_size - utilbox_size;
    }

    // Warning: If you've dropped an item, there may be blank items interleaved among the existing
    // items and some items will be pushed into the empty part of the box display
    PartiallyUsedBox util_box(utilbox_size,backpack_keys_amount);
    PartiallyUsedBox item_box(itembox_size,backpack_items_amount);

    uint lastindex; // Item with the highest index // Whatever that means? Not tested
    Attuned attunementslots[12];
    uint UnknownData1; // Going from hydra, to beating Ornstein & Smough, this changed from 1 to 0

    uint equippedItems[5]; // Could these also be the index-remember-previous-selection feature?

    UnknownTuple UnknownData2[10]<bgcolor=cLtYellow>;

    Color hair; // @ address: 0xE644
    Color eye; 
    CharacterParams creationdata;

    BottomlessBox box[backpack_amount];

    Gestures gestures;

    // End part of the play-through (NG+) counter looks like it's almost in a box struct?
    UnknownBlob1 playthrough_counter;
    UnknownBox unknown_box[64];
    UnknownStruct unknown_box_2[120];

    UnknownBlob2 counters;


    // Section length = 0x500
    BonfireSection firstsection;
    UnknownBulkSection unknownSections[72];
    //unknownSection[2].marker[8] Includes the bit that unlocks the Undead Burg ladder shortcut. Bit 0x08 if my calculations are correct
    //unknownSection[2].marker[91] 0A-08 indicates whether Sunlight Altar bonfire has been lit?

    byte zerofill[10] <bgcolor=cWhite,fgcolor=cGreen>;

    local uint mark = FTell();

    OnlineData online;

    // Dynamic length zero pad; skip to next part with numbers
    FSeek(mark + 131242);

    //0x56280 Undead Burg bonfire?
    UnknownArea areadata[2578] <fgcolor=cGray, bgcolor=cWhite>;  // I'm getting indications that this is just garbage data?
    if (hash_verified[1] == 0) {
        SetForeColor(cRed);
    }
    Checksum footer(16); // MD5 checksum of all bytes in this save slot (excluding header and length fields)
    SetForeColor(cNone);
    // Secondary checksum isn't actually required to be correct to form a valid save file; save file loads despite it being edited.

    ubyte offset[meta.chunks[slots].space_size] <bgcolor=cWhite>;
} SaveSlot <read=GetChecksumStatus, name=GetSlotCharName, comment=GetChecksumCorrection>;


string GetSlotCharName(SaveSlot &s) {
    return "SaveSlot (\"" + WStringToString(s.stats.name) + "\")";
}


typedef struct {
    local string header_hash_start = "";
    local string footer_hash_start = "";
    local string header_hash_calculated = "";
    local string footer_hash_calculated = "";
    local string header_hash_recalculated = "";
    local ubyte hash_verified[2] = GetChecksumStrings(FTell() + 20, (uint64)ReadUInt(FTell() + 16),
                                    meta.chunks[slots+1].start - (16 + meta.chunks[slots].space_size),
                                    header_hash_start, footer_hash_start, header_hash_calculated,
                                    footer_hash_calculated, header_hash_recalculated);

    if (ReadUInt(FTell()+16) != 0 && hash_verified[0] == 0) {
        SetForeColor(cRed);
    } else if (ReadUInt(FTell()+16) == 0) {
        SetForeColor(cGray);
    }
    Checksum header(16);
    SetForeColor(cNone);
    uint length <fgcolor=cWhite, bgcolor=cLtBlue>;
    ubyte data[8+4+0x4C];
    Stats stats;
    Pack pack(0);
    uint data2[3];
    byte utilbox[0x1c*64];
    byte itembox[0x1c*(2048-64)];
    byte data3[0x6c+0x10+0x10+0x28+0x14+4+0x64];
    byte bottomlessbox[0x20*2048];
    Gestures gestures;
    UnknownBlob1 playthrough_counter;
    UnknownBox unknown_box[64];
    UnknownStruct unknown_box_2[120];
    UnknownBlob2 counters;
    BonfireSection firstsection;
    byte unknownSections[72*0x500];
    byte zerofill[10] <bgcolor=cWhite,fgcolor=cGreen>;
    ubyte onlinedata[131242]<bgcolor=cLtPurple>;
    UnknownArea areadata[2578] <fgcolor=cGray, bgcolor=cWhite>;
    if (hash_verified[1] == 0) {
        SetForeColor(cRed);
    }
    Checksum footer(16);
    SetForeColor(cNone);
    ubyte offset[12] <bgcolor=cWhite>;
} EmptySlot <read=GetEmptySlotChecksumStatus, comment=GetEmptySlotChecksumCorrection>;


string GetChecksumStatus(SaveSlot &last_slot) {
    local string return_string = "";
    if (last_slot.length == 0) {
        return return_string;
    }
    if (last_slot.hash_verified[0] == 1 && last_slot.hash_verified[1] == 1) {
        SPrintf(return_string, "Header: %s (Valid)", last_slot.header_hash_calculated);
    } else if (last_slot.hash_verified[1] != 1) {
        SPrintf(return_string, "Header: %s (INVALID: Footer checksum is incorrect)", last_slot.header_hash_start);
    } else {
        SPrintf(return_string, "Header: %s (INVALID: Header checksum is incorrect)", last_slot.header_hash_start);
    }
    return return_string;
}

string GetChecksumCorrection(SaveSlot &last_slot) {
    local string return_string = "";
    if (last_slot.length == 0) {
        return return_string;
    }
    if (last_slot.hash_verified[0] == 1 && last_slot.hash_verified[1] == 1) {
        SPrintf(return_string, "Footer: %s (Valid)", last_slot.footer_hash_calculated);
    } else if (last_slot.hash_verified[1] != 1) {
        SPrintf(return_string, "Corrected footer: %s", last_slot.footer_hash_calculated);
    } else {
        SPrintf(return_string, "Corrected header: %s", last_slot.header_hash_calculated);
    }
    return return_string;
}

string GetEmptySlotChecksumStatus(EmptySlot &last_slot) {
    return "Empty slot";
    /*if (last_slot.length == 0) {
        return "Empty slot";
    }
    local string return_string = "";
    if (last_slot.hash_verified[0] == 1 && last_slot.hash_verified[1] == 1) {
        SPrintf(return_string, "Header: %s (Valid)", last_slot.header_hash_calculated);
    } else if (last_slot.hash_verified[1] != 1) {
        SPrintf(return_string, "Header: %s (INVALID: Footer checksum is incorrect)", last_slot.header_hash_start);
    } else {
        SPrintf(return_string, "Header: %s (INVALID: Header checksum is incorrect)", last_slot.header_hash_start);
    }
    return return_string;*/
}

string GetEmptySlotChecksumCorrection(EmptySlot &last_slot) {
    return "";
    /*local string return_string = "";
    if (last_slot.length == 0) {
        return return_string;
    }
    if (last_slot.hash_verified[0] == 1 && last_slot.hash_verified[1] == 1) {
        SPrintf(return_string, "Footer: %s (Valid)", last_slot.footer_hash_calculated);
    } else if (last_slot.hash_verified[1] != 1) {
        SPrintf(return_string, "Corrected footer: %s", last_slot.footer_hash_calculated);
    } else {
        SPrintf(return_string, "Corrected header: %s", last_slot.header_hash_calculated);
    }
    return return_string;*/
}

string GetMenuSlotChecksumStatus(MainMenu &mm) {
    local string return_string = "";
    if (mm.length == 0) {
        return return_string;
    }
    if (mm.hash_verified[0] == 1 && mm.hash_verified[1] == 1) {
        SPrintf(return_string, "Header: %s (Valid)", mm.header_hash_calculated);
    } else if (mm.hash_verified[1] != 1) {
        SPrintf(return_string, "Header: %s (INVALID: Footer checksum is incorrect)", mm.header_hash_start);
    } else {
        SPrintf(return_string, "Header: %s (INVALID: Header checksum is incorrect)", mm.header_hash_start);
    }
    return return_string;
}

string GetMenuSlotChecksumCorrection(MainMenu &mm) {
    local string return_string = "";
    if (mm.length == 0) {
        return return_string;
    }
    if (mm.hash_verified[0] == 1 && mm.hash_verified[1] == 1) {
        SPrintf(return_string, "Footer: %s (Valid)", mm.footer_hash_calculated);
    } else if (mm.hash_verified[1] != 1) {
        SPrintf(return_string, "Corrected footer: %s", mm.footer_hash_calculated);
    } else {
        SPrintf(return_string, "Corrected header: %s", mm.header_hash_calculated);
    }
    return return_string;
}

ubyte[2] GetChecksumStrings(uint start, uint64 size, uint secondary_start, string &current_primary, string &current_secondary,
                            string &calculated_primary, string &calculated_secondary, string &recalculated_primary) {
    local ubyte valid[2];
    valid[0] = 1;
    valid[1] = 1;
    if (size == 0) {
        current_primary = "                                ";
        current_secondary = "                                ";
        calculated_primary = "                                ";
        calculated_secondary = "                                ";
        recalculated_primary = "                                ";
        return valid;
    }
    local uchar md5_hash[33];
    //Printf("Secondary hash is calculated from byte %d (0x%x) to byte %d (0x%x) for a total of %d (0x%x) bytes (size - 16 bytes)\n", 20, 20, (size+(20-16)), (size+(20-16)), size-16, size-16);
    local int ret_bytes = ChecksumAlgBytes(CHECKSUM_MD5, md5_hash, start, size - 16);
    local uint current_ret_b = 0;
    for (current_ret_b = 0; current_ret_b < ret_bytes; current_ret_b++) {
        //Printf("current_ret_b = %u    ret_bytes = %d    secondary_start = %u\n", current_ret_b, ret_bytes, secondary_start);
        if (md5_hash[current_ret_b] != ReadUByte(secondary_start + current_ret_b)) {
            valid[1] = 0;
        }
        if(ReadUByte(secondary_start + current_ret_b) < 16) {
            SPrintf(current_secondary, "%s0", current_secondary);
        }
        SPrintf(current_secondary, "%s%x", current_secondary, ReadUByte(secondary_start + current_ret_b));
        if(md5_hash[current_ret_b] < 16) {
            SPrintf(calculated_secondary, "%s0", calculated_secondary);
        }
        SPrintf(calculated_secondary, "%s%x", calculated_secondary, md5_hash[current_ret_b]);
    }
    SPrintf(calculated_secondary, "%s", calculated_secondary);
    
    if (valid[1] != 1) {
        SPrintf(checksum_verification_messages,
          "%s[WARNING] Invalid footer checksum for slot %d:\n          Current hash:     %s\n          Calculated hash:  %s\n",
          checksum_verification_messages, slots, current_secondary, calculated_secondary);
    }
    
    // @TODO: If some preprocessor macro is defined, use void OverwriteBytes( int64 start, int64 size, uchar value=0 ) to overwrite incorrect checksums (or make copy of file with fixed)
    //Printf("Primary hash is calculated from byte %d (0x%x) to byte %d (0x%x) for a total of %d (0x%x) bytes (size + 4 bytes)\n", 16, 16, (size+(16+4)), (size+(16+4)), size + 4, size + 4);
    ret_bytes = ChecksumAlgBytes(CHECKSUM_MD5, md5_hash, start-4, size + 4);
    
    for (current_ret_b = 0; current_ret_b < ret_bytes; current_ret_b++) {
        if (md5_hash[current_ret_b] != ReadUByte((start-20) + current_ret_b)) {
            valid[0] = 0;
        }
        if(ReadUByte((start-20) + current_ret_b) < 16) {
            SPrintf(current_primary, "%s0", current_primary);
        }
        SPrintf(current_primary, "%s%x", current_primary, ReadUByte((start-20) + current_ret_b));
        if(md5_hash[current_ret_b] < 16) {
            SPrintf(calculated_primary, "%s0", calculated_primary);
        }
        SPrintf(calculated_primary, "%s%x", calculated_primary, md5_hash[current_ret_b]);
    }
    
    if (valid[0] != 1) {
        SPrintf(checksum_verification_messages,
          "%s[WARNING] Invalid header checksum for slot %d:\n          Current hash:     %s\n          Calculated hash:  %s\n",
          checksum_verification_messages, slots, current_primary, calculated_primary);
    }
    
    if (valid[0] != 1 || valid[0] != 1) {
        SPrintf(checksum_verification_messages, "%s\n", checksum_verification_messages);
    }
    
    // @TODO: If footer hash is invalid, recalculate header using correct footer
    
    return valid;
}


LittleEndian(); 

local uint tag = ReadUInt( FTell() );

// IDENTIFY BND4 token
// This is 0x20434f43 for x360 saves ("COC "?)
// Another tag for x360 is at 0x360: 3a084d4e (Little Endian)
if( tag != 0x34444e42)
{
    Warning("Not a valid Dark Souls: Prepare to die Edition save file");
    return -1;
}

SetBackColor( cLtGray );
BND4 meta;

// Slots should be configured according to record's ContainerCount // Not really, what if you've deleted slot 1 but slot 2 exists?
if (meta.SlotMetaBlockSize != 0x20)
{
    Warning("Not a valid Dark Souls: prepare to Die Edition save file");
    return -1;
}

local uint slots = 0;
local ubyte test = 0;
local ubyte slot_filled[meta.ContainerCount - 1];
for( slots = 0; slots < meta.ContainerCount; slots++ )
{
    // If a main menu flag has value of 1, corresponding save slot is occupied
    
    if(slots != (meta.ContainerCount - 1))
    {
        if (FTell() != meta.chunks[slots].start) {
            //ubyte UNKNOWN_DATA[meta.chunks[slots].start - FTell()];
            FSeek(meta.chunks[slots].start);
        }
        test = ReadUByte(meta.chunks[meta.ContainerCount - 1].start + 40 + slots);
        if( test == 1 ) {
            slot_filled[slots] = 1;
            SaveSlot slot;
        } else {
            slot_filled[slots] = 0;
            EmptySlot empty;
        }
    } else {
        MainMenu menu_data;
    }
}

SetBackColor(cRed);
while(!FEof()) {
    ubyte eof_padding <comment="Unknown bytes; verify that this is a valid Dark Souls: PtDE save file and check that the template is working correctly.">;
}
SetBackColor(cLtGray);

Printf("%s", checksum_verification_messages);

#endif // _DS1_SL2_BT