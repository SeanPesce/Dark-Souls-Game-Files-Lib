//----------------------------------------------------------------------------
//--- 010 Editor v5.0 Binary Template
//
// File: Sl2/Sl2.bt
// Author: Tarvitz & Sean Pesce
// Revision: 0.0.1
// Purpose: Parsing Dark Souls: Prepare to Die Edition save files (*.sl2)
//----------------------------------------------------------------------------
#ifndef _DS1_SL2_BT
    #define _DS1_SL2_BT

#include "Bnd4.bt";
#include "Character.bt";
#include "Backpack.bt"
#include "Unknown.bt";
#include "../Online.bt";
#include "MainMenu.bt";
#include "../Enum/Location.bt";
#include "../Enum/Character.bt"

typedef struct{
    ubyte flag1 : 1 ;
    ubyte flag2 : 1 ;
    ubyte flag3 : 1 ;
    ubyte flag4 : 1 ;
    ubyte flag5 : 1 ;
    ubyte flag6 : 1 ;
    ubyte flag7 : 1 ;
    ubyte flag8 : 1 ;
} BitFlags;

typedef struct{
    ubyte face_geo_data[50] <bgcolor=cLtYellow>;
    // I suspect the character creation options can be found around here
    ubyte skin_tone <bgcolor=cLtYellow, fgcolor=cBlue>;
    ubyte face_tex_data[49] <bgcolor=cLtYellow>;
    byte UnknownData4[8];
} CharacterParams;

typedef struct{
    Item magic;
    uint count;
} Attuned;

// I'm not sure exactly how these map, if they are just shorts or UnknownTuple
typedef struct{
    UnknownTuple unknown1 <bgcolor=cLtYellow>;
    UnknownTuple petrus <comment="Shrug = 21, Look Skyward = 23, Unlearned = 20">;
    UnknownTuple unknown3 <bgcolor=cLtYellow>;
    UnknownTuple unknown4 <bgcolor=cLtYellow>;
} LearnedGestures;

typedef struct{
    UnknownTuple UnknownData5a[10] <bgcolor=cLtYellow>;
    // Equipped gestures are stored somewhere else, this is specifically if they are available or not
    // Enabling this won't remove the dialog option and vice verse
    LearnedGestures gestures;
    //maybe more gestures?
    UnknownTuple UnknownData5b[4] <bgcolor=cLtYellow>;
    uint ZeroPad[16] <bgcolor=cWhite>;
} Gestures;

// This is specifically bonfires RESTED AT, not lit. (i.e. relevant to which bonfires player can warp to. Only warpable bonfires in this struct??)
typedef struct{

    // I noticed that if you do not light any bonfires in the Undead Asylum, and then you die after running past the second bonfire, your spawn point is still set there.
    // Most likely the game state moves your spawn point automatically during the tutorial so you don't get trapped behind the locked gate.

    // 2,8,13,14,28,29,30
    // Must be from {depths, fairlady, anorlondo1, anorlondotomb, paintedworld, tombgiants1}?
    // Undead Burg first bonfire not here
    uint bonfireenabled1 : 1 <comment="Undead Parish"> ;
    uint bonfireenabled2 : 1 ;
    uint bonfireenabled3 : 1 ;
    uint bonfireenabled4 : 1 ;
    uint bonfireenabled5 : 1 ;
    uint bonfireenabled6 : 1 ;
    uint bonfireenabled7 : 1 ;
    uint bonfireenabled8 : 1 ;
    uint bonfireenabled9 : 1 <comment="Chamber of the Princess">;
    uint bonfireenabled10 : 1 ;
    uint bonfireenabled11 : 1 <comment="Altar of Sunlight">;
    uint bonfireenabled12 : 1 ;
    uint bonfireenabled13 : 1 ;
    uint bonfireenabled14 : 1 ;
    uint bonfireenabled15 : 1 ;
    uint bonfireenabled16 : 1 <comment="Firelink Shrine">; // Enabled when arriving at Firelink first time
    uint bonfireenabled17 : 1 ;
    uint bonfireenabled18 : 1 ;
    uint bonfireenabled19 : 1 ;
    uint bonfireenabled20 : 1 ;
    uint bonfireenabled21 : 1 ;
    uint bonfireenabled22 : 1 ;
    uint bonfireenabled23 : 1 ;
    uint bonfireenabled24 : 1 ;
    uint bonfireenabled25 : 1 ;
    uint bonfireenabled26 : 1 ;
    uint bonfireenabled27 : 1 ;
    uint bonfireenabled28 : 1 ;
    uint bonfireenabled29 : 1 ;
    uint bonfireenabled30 : 1 ;
    uint bonfireenabled31 : 1 ;
    uint bonfireenabled32 : 1 ;
} Bonfires;

typedef struct{
    uint unknown[4]; // I think here is where we can find bonfire 'lit' info
    byte UnknownData8b[38-20] <bgcolor=cLtYellow>;
    Bonfires bonfiresRestedAt<bgcolor=cLtGreen>;
    byte unknown2[214] <bgcolor=cLtYellow>;
    byte filler[788] <bgcolor=cWhite>;
    byte unknown3[224] <bgcolor=cLtYellow>;
    byte filler2[16] <bgcolor=cWhite>;
} BonfireSection;

typedef struct {
    local int unknown_size_1 = sizeof(StatsUnknown1);
    local int stats_size = sizeof(Stats);
    local int pack_size = sizeof(Pack);
    local int backpack_amount = 2048; // is this hard code constant? // I don't know, we could try filling the backpack 
    // with 2047 items and see what happens when we try to pick up another. If it refuses it's constant, if it dynamically resizes the 
    // pack then we know


    Checksum header; // This is written after the MD5 in the footer of the save slot is written, it includes all parts of the save slot except for the ChecksumHeader
    uint length <fgcolor=cWhite, bgcolor=cLtBlue>; // Number of bytes that should be included in the checksum, 393216 ( Entire slot is 393248 )
    uint unknown_a[2];
    uint playtime <comment="Time in milliseconds; maxes out at 999:59:59 (3599999000)">; // Milliseconds since game start (verified); maxes out at 3599999000 (999:59:59)
    StatsUnknown1 unknown <comment="Unknown data">;

    Stats stats;
    Pack pack;

    uint backpack_items_amount;
    uint backpack_keys_amount;
    uint backpack_size;
    // 0-63 indexes for utils box
    local uint utilbox_size = 64;
    local uint itembox_size = 0;
    if(backpack_size > 0 && backpack_size >= utilbox_size) {
        itembox_size = backpack_size - utilbox_size;
    }

    // Warning: If you've dropped an item, there may be blank items interleaved among the existing
    // items and some items will be pushed into the empty part of the box display
    PartiallyUsedBox util_box(utilbox_size,backpack_keys_amount);
    PartiallyUsedBox item_box(itembox_size,backpack_items_amount);

    uint lastindex; // Item with the highest index // Whatever that means? Not tested
    Attuned attunementslots[12];
    uint UnknownData1; // Going from hydra, to beating Ornstein & Smough, this changed from 1 to 0

    uint equippedItems[5]; // Could these also be the index-remember-previous-selection feature?

    UnknownTuple UnknownData2[10]<bgcolor=cLtYellow>;

    Color hair; // @ address: 0xE644
    Color eye; 
    CharacterParams creationdata;

    BottomlessBox box[backpack_amount];

    Gestures gestures;

    // End part of the play-through (NG+) counter looks like it's almost in a box struct?
    UnknownBlob1 playthrough_counter;
    UnknownBox unknown_box[64];
    UnknownStruct unknown_box_2[120];

    UnknownBlob2 counters;


    // Section length = 0x500
    BonfireSection firstsection;
    UnknownBulkSection unknownSections[72];
    //unknownSection[2].marker[8] Includes the bit that unlocks the Undead Burg ladder shortcut. Bit 0x08 if my calculations are correct
    //unknownSection[2].marker[91] 0A-08 indicates whether Sunlight Altar bonfire has been lit?

    byte zerofill[10] <bgcolor=cWhite,fgcolor=cGreen>;

    local uint mark = FTell();

    OnlineData online;

    // Dynamic length zero pad; skip to next part with numbers
    FSeek(mark + 131242);

    //0x56280 Undead Burg bonfire?
    UnknownArea areadata[2578] <fgcolor=cGray, bgcolor=cWhite>;  // I'm getting indications that this is just garbage data?

    Checksum secondary; // MD5 checksum of all bytes in this save slot (excluding header and length fields)
    // Secondary checksum isn't actually required to be correct to form a valid save file; save file loads despite it being edited.

    ubyte offset[meta.chunks[slots].space_size] <bgcolor=cWhite>;
} SaveSlot;

typedef struct {
    Checksum header;
    uint length <fgcolor=cWhite, bgcolor=cLtBlue>;
    ubyte data[8+4+0x4C];
    Stats stats;
    Pack pack;
    uint data2[3];
    byte utilbox[0x1c*64];
    byte itembox[0x1c*(2048-64)];
    byte data3[0x6c+0x10+0x10+0x28+0x14+4+0x64];
    byte bottomlessbox[0x20*2048];
    Gestures gestures;
    UnknownBlob1 playthrough_counter;
    UnknownBox unknown_box[64];
    UnknownStruct unknown_box_2[120];
    UnknownBlob2 counters;
    BonfireSection firstsection;
    byte unknownSections[72*0x500];
    byte zerofill[10] <bgcolor=cWhite,fgcolor=cGreen>;
    ubyte onlinedata[131242]<bgcolor=cLtPurple>;
    UnknownArea areadata[2578] <fgcolor=cGray>; 
    Checksum secondary;
    ubyte offset[12] <bgcolor=cWhite>;
} EmptySlot;


LittleEndian(); 

local uint tag = ReadUInt( FTell() );

// IDENTIFY BND4 token
// This is 0x20434f43 for x360 saves ("COC "?)
// Another tag for x360 is at 0x360: 3a084d4e (Little Endian)
if( tag != 0x34444e42)
{
    Warning("Not a valid Dark Souls: Prepare to die Edition save file");
    return -1;
}

SetBackColor( cLtGray );
BND4 meta;

// Slots should be configured according to record's ContainerCount // Not really, what if you've deleted slot 1 but slot 2 exists?
if (meta.SlotMetaBlockSize != 0x20)
{
    Warning("Not a valid Dark Souls: prepare to Die Edition save file");
    return -1;
}

local uint slots = 0;
local ubyte test = 0;
local ubyte slot_filled[meta.ContainerCount - 1];
for( slots = 0; slots < meta.ContainerCount; slots++ )
{
    // If a main menu flag has value of 1, corresponding save slot is occupied
    
    if(slots != (meta.ContainerCount - 1))
    {
        test = ReadUByte(meta.chunks[meta.ContainerCount - 1].start + 40 + slots);
        if( test == 1 ) {
            slot_filled[slots] = 1;
            SaveSlot slot;
        } else {
            slot_filled[slots] = 0;
            EmptySlot empty;
        }
    } else {
        MainMenu menu_data;
    }
}

SetBackColor(cRed);
while(!FEof()) {
    ubyte eof_padding <comment="Unknown bytes; verify that this is a valid Dark Souls: PtDE save file and check that the file-reader script is working correctly.">;
}
SetBackColor(cLtGray);

#endif // _DS1_SL2_BT